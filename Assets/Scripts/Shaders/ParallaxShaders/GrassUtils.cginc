#include "UnityCG.cginc"
#include "Lighting.cginc"
float4 _Color;
float _Shininess;

float4 BlinnPhong(float3 normal, float3 pos, float4 diffuseCol)
{
    half3 lightDir = normalize(_WorldSpaceLightPos0.xyz);
    half3 viewDir = normalize(_WorldSpaceCameraPos.xyz - pos);
    half3 halfDir = normalize(lightDir + viewDir);

    // Dot
    half NdotL = saturate(dot(normal, lightDir));
    half NdotH = saturate(dot(normal, halfDir));
    // Color
    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb * diffuseCol.rgb;
    fixed3 diffuse = _LightColor0.rgb * diffuseCol.rgb * NdotL;
    fixed3 specular = _LightColor0.rgb * _SpecColor.rgb * pow(NdotH, _Shininess);
    specular *= diffuseCol.a;
    fixed4 color = fixed4(ambient + diffuse + specular, 1.0);

    return color;
}
float4 LightingBlinnPhong(float3 world_vertex, float3 lightDir, float3 worldNormal, float4 diffuseCol, float3 lightAttenuation)
{
    //float3 normal = lerp(basicNormal, worldNormal, _NormalSpecularInfluence);
    //float3 viewDirection = normalize(_WorldSpaceCameraPos.xyz - world_vertex.xyz);
    //float3 halfDirection = normalize(viewDirection + lightDir);
    //float NdotL = max(0, dot(worldNormal, lightDir));
    //float NdotV = max(0, dot(normal, halfDirection));
    //
    //NdotL = pow(NdotL, _Hapke);
    //
	////Specular calculations
    //float3 specularity = pow(NdotV, _Gloss * alpha) * _Metallic * _MetallicTint.rgb * alpha;
    //float angle = saturate(dot(normalize(worldNormal), lightDir));
    //
    //float3 lightingModel = NdotL * col + specularity;
    //
    //float3 attenColor = lightAttenuation * _LightColor0.rgb;
    //float4 finalDiffuse = float4(lightingModel * attenColor, 0);
    //return finalDiffuse;
    
    
    
    half3 viewDir = normalize(_WorldSpaceCameraPos.xyz - world_vertex.xyz);
    half3 halfDir = normalize(lightDir + viewDir);

    //worldNormal = lerp(worldNormal, lightDir, 0.5);
    // Dot
    half NdotL = saturate(dot(worldNormal, lightDir));
    half NdotV = saturate(dot(worldNormal, halfDir));
    // Color

    fixed3 diffuse = lightAttenuation.rgb * diffuseCol.rgb * NdotL;
    fixed3 specular = lightAttenuation.rgb * _SpecColor.rgb * pow(NdotV, _Shininess);
    specular *= diffuseCol.a;
    float3 attenColor = lightAttenuation * _LightColor0;
    fixed4 color = fixed4(diffuse + specular, lightAttenuation.r);
    
    return color;
}
float BlinnPhongBubble(float3 normal, float3 planetNormal)
{
    float ndotl = saturate(1 - pow(1 - dot(normal, planetNormal), 8) + 0.75);
    

    return ndotl * _LightColor0;
}
float4x4 GetTranslationMatrix(float3 pos)
{
    return  float4x4(float4(1, 0, 0, pos.x), float4(0, 1, 0, pos.y), float4(0, 0, 1, pos.z), float4(0, 0, 0, 1));//
}
float InterleavedGradientNoise2(float2 uv)
{
    const float3 magic = float3(0.06711056, 0.00583715, 52.9829189);
    return frac(magic.z * frac(dot(uv, magic.xy)));
}
float InterleavedGradientNoise(float2 uv)
{
    return frac(sin(dot(uv / 10, float2(12.9898, 78.233))) * 43758.5453123);
}
void Billboard(inout float4 vertex, float4x4 mat)
{
    float4x4 localMat = mul(mat, unity_WorldToObject);

    const float3 local = float3(vertex.x, vertex.y, vertex.z); // this is the quad verts as generated by MakeMesh.cs in the localPos list.
    const float3 offset = vertex.xyz - local;
 
    const float3 upVector = float3(0, 1, 0);
    const float3 forwardVector = mul(UNITY_MATRIX_IT_MV[2].xyz, localMat); // camera forward   
    const float3 rightVector = normalize(cross(forwardVector, upVector));
 
    float3 position = 0;
    position += local.x * rightVector;
    position += local.y * upVector;
    position += local.z * forwardVector;
 
    vertex = float4(offset + position, 1);
}
void AllAxisBillboard(inout float4 vertex, float4x4 mat)
{
    float4x4 localMat = unity_ObjectToWorld;//mul(mat, unity_WorldToObject);

    const float3 local = mul(mat, float3(vertex.x, vertex.y, vertex.z)); // this is the quad verts as generated by MakeMesh.cs in the localPos list.
    const float3 offset = vertex.xyz - local;
 
    const float3 upVector = float3(0, 1, 0);
    const float3 forwardVector = UNITY_MATRIX_T_MV[2].xyz; // camera forward   
    const float3 rightVector = normalize(cross(forwardVector, upVector));
 
    float3 position = 0;
    position += local.x * rightVector;
    position += local.y * upVector;
    position += local.z * forwardVector;
    //position = mul(viewMat, local);
    vertex = float4(offset + position, 1);

}
float3 Fresnel(float3 normal, float3 viewDir, float smoothness, float3 color)
{
    float fresnel = dot(normal, viewDir);
    fresnel = saturate(1 - fresnel);
    fresnel = pow(fresnel, smoothness);
    return fresnel * color;
}